<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Pro Parking: Ultimate Fixed</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #dfe6e9; font-family: 'Poppins', sans-serif; touch-action: none; }
        
        .ui-panel {
            position: absolute; background: rgba(255, 255, 255, 0.95); border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1); color: #2d3436; padding: 12px 24px;
            border-radius: 16px; pointer-events: auto; user-select: none; backdrop-filter: blur(10px);
            display: flex; gap: 20px; align-items: center;
        }
        #top-bar { top: 20px; left: 20px; }
        .hud-item { display: flex; flex-direction: column; min-width: 60px; }
        .hud-label { font-size: 10px; color: #636e72; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
        .hud-val { font-size: 22px; font-weight: 800; color: #2d3436; }

        .action-btn {
            border: none; color: white; padding: 10px 20px; border-radius: 12px; cursor: pointer; 
            font-family: inherit; font-weight: 700; font-size: 13px; transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15); min-width: 110px; text-transform: uppercase;
        }
        .action-btn:active { transform: scale(0.96); }
        #music-btn { background: linear-gradient(135deg, #6c5ce7, #a29bfe); }
        #engine-btn { background: linear-gradient(135deg, #e17055, #fab1a0); }
        #music-btn.active { background: linear-gradient(135deg, #00b894, #55efc4); box-shadow: 0 4px 15px rgba(0, 184, 148, 0.3); }
        #engine-btn.active { background: linear-gradient(135deg, #00b894, #55efc4); box-shadow: 0 4px 15px rgba(0, 184, 148, 0.3); }

        #gear-display {
            position: absolute; bottom: 180px; right: 30px;
            display: flex; flex-direction: column; gap: 8px;
            background: rgba(255,255,255,0.9); padding: 15px; border-radius: 16px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        .gear { font-size: 20px; color: #b2bec3; font-weight: 800; padding: 6px 14px; text-align: center; border-radius: 8px; transition: all 0.2s; }
        .gear.active { color: #fff; background: #0984e3; box-shadow: 0 4px 12px rgba(9, 132, 227, 0.3); transform: scale(1.1); }

        #steering-hud {
            position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%);
            width: 240px; height: 6px; background: rgba(0,0,0,0.1); border-radius: 3px;
        }
        #steering-dot {
            width: 18px; height: 18px; background: #0984e3; border-radius: 50%; border: 3px solid white;
            position: absolute; top: -6px; left: 50%; transform: translateX(-50%);
            box-shadow: 0 3px 10px rgba(9, 132, 227, 0.4);
        }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(236, 240, 241, 0.95); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(10px);
        }
        #game-over-screen { display: none; }
        h1 { font-size: 56px; color: #2d3436; margin: 0; font-weight: 900; letter-spacing: -2px; }
        p { color: #636e72; margin-bottom: 40px; font-size: 20px; font-weight: 500; }

        .btn-main {
            padding: 20px 70px; font-size: 20px; font-weight: 800;
            background: linear-gradient(45deg, #0984e3, #74b9ff);
            border: none; color: white; border-radius: 60px; cursor: pointer;
            box-shadow: 0 15px 30px rgba(9, 132, 227, 0.4);
            transition: transform 0.2s, box-shadow 0.2s; letter-spacing: 1px;
        }
        .btn-main:active { transform: scale(0.96); box-shadow: 0 8px 20px rgba(9, 132, 227, 0.4); }

        .controls-area {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 50px; box-sizing: border-box;
            pointer-events: none; z-index: 10;
        }
        .control-group { pointer-events: auto; display: flex; gap: 25px; }
        .game-btn {
            width: 90px; height: 90px;
            background: rgba(255,255,255,0.95); border: 2px solid #eee;
            border-radius: 50%; color: #2d3436; font-size: 34px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            transition: all 0.1s;
        }
        .game-btn:active, .game-btn.active { background: #f1f2f6; transform: scale(0.94); box-shadow: 0 5px 15px rgba(0,0,0,0.1); border-color: #dcdde1; }
        #btn-brake { color: #d63031; } #btn-brake:active { background: #d63031; color: white; border-color: #c0392b; }
    </style>
</head>
<body>

    <div id="top-bar" class="ui-panel">
        <div class="hud-item"><span class="hud-label">LEVEL</span><span class="hud-val" id="level-display">1</span></div>
        <div class="hud-item"><span class="hud-label">KM/H</span><span class="hud-val" id="speed-display">0</span></div>
        <button id="engine-btn" class="action-btn" onclick="toggleEngine()">MOTOR BAŞLAT</button>
        <button id="music-btn" class="action-btn" onclick="toggleMusic()">RADYO AÇ</button>
    </div>

    <div id="gear-display">
        <div id="gear-d" class="gear">D</div>
        <div id="gear-n" class="gear active">N</div>
        <div id="gear-r" class="gear">R</div>
    </div>

    <div id="steering-hud"><div id="steering-dot"></div></div>

    <div id="start-screen" class="overlay">
        <h1>PARK USTASI</h1>
        <p>Gerçekçi Sürüş Deneyimi</p>
        <button class="btn-main" onclick="startGame()">OYUNU BAŞLAT</button>
    </div>

    <div id="game-over-screen" class="overlay">
        <h1 id="go-title">HARİKA!</h1>
        <p id="go-desc">Park işlemi tamamlandı.</p>
        <button class="btn-main" id="go-btn" onclick="nextLevel()">SONRAKİ BÖLÜM</button>
    </div>

    <div class="controls-area">
        <div class="control-group">
            <div id="btn-left" class="game-btn">◀</div>
            <div id="btn-right" class="game-btn">▶</div>
        </div>
        <div class="control-group">
            <div id="btn-brake" class="game-btn">⛔</div> 
            <div id="btn-gas" class="game-btn">▲</div>   
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

        let scene, camera, renderer;
        let car, carBody, wheels = [];
        let parkingSpot;
        let obstacles = [];
        let environmentGroup = new THREE.Group();
        let asphaltTexture;

        let keys = { w: false, a: false, s: false, d: false };
        let speed = 0;
        let carRotation = 0; 
        let steeringAngle = 0; 
        let isGameOver = false;
        let currentLevel = 0;
        
        // HATA DÜZELTME: Başlangıç koruması için değişken
        let collisionEnabled = false;

        const MAX_SPEED = 0.55;
        const ACCEL = 0.009;
        const FRICTION = 0.96;
        const MAX_STEER = 0.65; 
        const TURN_SPEED = 0.045; 

        // --- SES SİSTEMİ ---
        let audioCtx, masterGain;
        let engineOsc, engineGain, engineFilter, isEngineRunning = false;
        let musicGain, isMusicPlaying = false, musicInterval, noteIndex = 0;

        window.startGame = function() {
            document.getElementById('start-screen').style.display = 'none';
            startEngineAutomatically(); 
            loadLevel(0);
        };

        window.nextLevel = function() {
            currentLevel = (currentLevel + 1) % levels.length;
            loadLevel(currentLevel);
        };

        window.toggleEngine = function() {
            if(!audioCtx) initAudio();
            const btn = document.getElementById('engine-btn');
            if(!isEngineRunning) {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                engineOsc = audioCtx.createOscillator(); engineOsc.type = 'sawtooth'; engineOsc.frequency.value = 60;
                engineFilter = audioCtx.createBiquadFilter(); engineFilter.type = 'lowpass'; engineFilter.frequency.value = 300;
                engineGain = audioCtx.createGain(); engineGain.gain.value = 0.15;
                engineOsc.connect(engineFilter); engineFilter.connect(engineGain); engineGain.connect(masterGain);
                engineOsc.start(); isEngineRunning = true;
                btn.innerText = "MOTOR AÇIK"; btn.classList.add('active');
            } else {
                if(engineGain) engineGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5);
                setTimeout(() => { if(engineOsc) { try{ engineOsc.stop(); }catch(e){} } }, 500);
                isEngineRunning = false;
                btn.innerText = "MOTOR BAŞLAT"; btn.classList.remove('active');
            }
        };

        function startEngineAutomatically() {
             if(!audioCtx) initAudio();
             if(isEngineRunning) return;
             window.toggleEngine();
        }

        function stopEngine() { if(isEngineRunning) window.toggleEngine(); }

        window.toggleMusic = function() {
            if(!audioCtx) initAudio();
            const btn = document.getElementById('music-btn');
            if(!isMusicPlaying) {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                startMusicSequencer(); isMusicPlaying = true;
                btn.innerText = "RADYO AÇIK"; btn.classList.add('active');
            } else {
                stopMusicSequencer(); isMusicPlaying = false;
                btn.innerText = "RADYO AÇ"; btn.classList.remove('active');
            }
        }

        function initAudio() {
            if(audioCtx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            masterGain = audioCtx.createGain(); masterGain.gain.value = 0.5; masterGain.connect(audioCtx.destination);
            musicGain = audioCtx.createGain(); musicGain.gain.value = 0.4; musicGain.connect(masterGain);
        }

        function updateEngineSound() {
            if(!isEngineRunning || isGameOver || !engineOsc) return;
            const speedRatio = Math.abs(speed) / MAX_SPEED; const currentTime = audioCtx.currentTime;
            engineOsc.frequency.setTargetAtTime(60 + (speedRatio * 200), currentTime, 0.1);
            engineFilter.frequency.setTargetAtTime(300 + (speedRatio * 1500), currentTime, 0.1);
            engineGain.gain.setTargetAtTime(0.15 + (speedRatio * 0.2), currentTime, 0.1);
        }

        function startMusicSequencer() {
            if(musicInterval) clearInterval(musicInterval);
            noteIndex = 0; const tempo = 220;
            musicInterval = setInterval(() => {
                const t = audioCtx.currentTime; const step = noteIndex % 16;
                if (step % 4 === 0) playDrum(t, 120, 0.5);
                if (step % 2 === 0) playHiHat(t);
                const bassNotes = [65.41, 0, 0, 65.41, 58.27, 0, 0, 58.27, 48.99, 0, 0, 48.99, 58.27, 0, 65.41, 0];
                if(bassNotes[step] > 0) playSynth(t, bassNotes[step], 'sawtooth', 0.15, 0.2);
                if(step === 0 || step === 8) { playSynth(t, 261.63, 'triangle', 0.1, 1.0); playSynth(t, 329.63, 'triangle', 0.1, 1.0); }
                noteIndex++;
            }, tempo);
        }
        function stopMusicSequencer() { clearInterval(musicInterval); }
        function playDrum(t, freq, vol) { const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.frequency.setValueAtTime(freq, t); osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5); g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.5); osc.connect(g); g.connect(musicGain); osc.start(t); osc.stop(t + 0.5); }
        function playHiHat(t) { const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.type = 'square'; osc.frequency.setValueAtTime(8000, t); g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.05); osc.connect(g); g.connect(musicGain); osc.start(t); osc.stop(t + 0.05); }
        function playSynth(t, freq, type, vol, dur) { const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.type = type; osc.frequency.setValueAtTime(freq, t); g.gain.setValueAtTime(vol, t); g.gain.linearRampToValueAtTime(0, t + dur); const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 800; osc.connect(f); f.connect(g); g.connect(musicGain); osc.start(t); osc.stop(t + dur); }
        function playSFX(type) { if(!audioCtx) return; const t = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const g = audioCtx.createGain(); osc.connect(g); g.connect(masterGain); if(type === 'win') { osc.type = 'sine'; osc.frequency.setValueAtTime(523, t); osc.frequency.linearRampToValueAtTime(1046, t+0.5); g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t+0.5); osc.start(t); osc.stop(t+0.5); } else if (type === 'crash') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t+0.3); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.3); osc.start(t); osc.stop(t+0.3); } }
        
        function generateAsphaltTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#333333'; ctx.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 80000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512; 
                const gray = Math.random() * 120 + 40; 
                ctx.fillStyle = `rgb(${gray},${gray},${gray})`; ctx.fillRect(x, y, 2, 2);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(25, 25);
            return texture;
        }

        const levels = [
            { car: {x: -5, z: 35, rot: 0}, spot: {x: 10, z: 0, rot: 0}, obstacles: [{type:'car', x:10, z:-10, rot:0}, {type:'car', x:10, z:10, rot:0}] },
            { car: {x: 15, z: 35, rot: Math.PI}, spot: {x: -10, z: 0, rot: 0}, obstacles: [{type:'car', x:-10, z:-10, rot:Math.PI}, {type:'car', x:-10, z:10, rot:Math.PI}, {type:'curb', x:0, z:25, w:30, h:1}] },
            { car: {x: 0, z: 40, rot: 0}, spot: {x: 10, z: 20, rot: Math.PI/2}, obstacles: [{type:'car', x:10, z:10, rot:0}, {type:'car', x:10, z:30, rot:0}, {type:'cone', x:0, z:15}, {type:'cone', x:0, z:25}] }
        ];

        init();
        animate();

        function init() {
            asphaltTexture = generateAsphaltTexture();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdfe6e9); 
            scene.fog = new THREE.Fog(0xdfe6e9, 50, 150);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(60, 100, 40);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.camera.left = -80; dirLight.shadow.camera.right = 80;
            dirLight.shadow.camera.top = 80; dirLight.shadow.camera.bottom = -80;
            scene.add(dirLight);

            scene.add(environmentGroup);

            window.addEventListener('keydown', (e) => handleKey(e.key, true));
            window.addEventListener('keyup', (e) => handleKey(e.key, false));
            setupTouch('btn-gas', 'w'); setupTouch('btn-brake', 's');
            setupTouch('btn-left', 'a'); setupTouch('btn-right', 'd');
            window.addEventListener('resize', onResize);
        }

        function loadLevel(idx) {
            isGameOver = false;
            // HATA ÇÖZÜMÜ: Başlangıçta çarpışmayı devre dışı bırak
            collisionEnabled = false;
            
            // 1 saniye sonra çarpışmayı aktif et
            setTimeout(() => { collisionEnabled = true; }, 1000);

            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('level-display').innerText = idx + 1;
            
            while(environmentGroup.children.length > 0) { environmentGroup.remove(environmentGroup.children[0]); }
            obstacles = []; wheels = [];
            
            createParkingLotEnvironment();
            const lvl = levels[idx];
            createCar(lvl.car.x, lvl.car.z, lvl.car.rot, 0xe17055, true);
            
            speed = 0; steeringAngle = 0;
            createParkingLines(lvl.spot.x, lvl.spot.z, lvl.spot.rot);
            
            lvl.obstacles.forEach(obj => {
                if(obj.type === 'car') createObstacleCar(obj);
                if(obj.type === 'cone') createCone(obj);
                if(obj.type === 'curb') createCurbObstacle(obj);
            });
        }

        function createParkingLotEnvironment() {
            const groundGeo = new THREE.PlaneGeometry(160, 160);
            const groundMat = new THREE.MeshStandardMaterial({ map: asphaltTexture, roughness: 0.8, metalness: 0.1 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true;
            environmentGroup.add(ground);

            const curbMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7, roughness: 0.9 });
            const createCurb = (x, z, w, h, rotY=0) => {
                const curb = new THREE.Mesh(new THREE.BoxGeometry(w, 0.6, h), curbMat);
                curb.position.set(x, 0.3, z); curb.rotation.y = rotY; curb.castShadow = true; curb.receiveShadow = true;
                environmentGroup.add(curb); obstacles.push(curb);
            };
            createCurb(0, -78, 156, 1); createCurb(0, 78, 156, 1);
            createCurb(-78, 0, 1, 156); createCurb(78, 0, 1, 156);

            const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
            const drawParkingBay = (x, z, rotY) => {
                 const bay = new THREE.Group();
                 const lineWidth = 0.15; const bayWidth = 3.2; const bayLength = 5.5;
                 const sideGeo = new THREE.PlaneGeometry(lineWidth, bayLength);
                 const lineL = new THREE.Mesh(sideGeo, lineMat); lineL.rotation.x = -Math.PI/2; lineL.position.set(-bayWidth/2, 0, 0); bay.add(lineL);
                 const lineR = new THREE.Mesh(sideGeo, lineMat); lineR.rotation.x = -Math.PI/2; lineR.position.set(bayWidth/2, 0, 0); bay.add(lineR);
                 const backGeo = new THREE.PlaneGeometry(bayWidth + lineWidth, lineWidth);
                 const lineB = new THREE.Mesh(backGeo, lineMat); lineB.rotation.x = -Math.PI/2; lineB.position.set(0, 0, -bayLength/2); bay.add(lineB);
                 bay.position.set(x, 0.02, z); bay.rotation.y = rotY;
                 environmentGroup.add(bay);
            };

            for(let i = -5; i <= 5; i++) {
                drawParkingBay(-20, i * 10, 0);
                drawParkingBay(20, i * 10, Math.PI);
            }
        }

        function createCar(x, z, rot, colorHex, isPlayer = false) {
            const newCar = new THREE.Group();
            
            const bodyMat = new THREE.MeshStandardMaterial({color: colorHex, metalness: 0.7, roughness: 0.3});
            const glassMat = new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.9, roughness: 0.1, transparent:true, opacity:0.8});
            const lightMat = new THREE.MeshStandardMaterial({color: 0xffffff, metalness: 0.1});

            const base = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.6, 4.6), bodyMat);
            base.position.y = 0.5; base.castShadow = true; newCar.add(base);

            const top = new THREE.Mesh(new THREE.BoxGeometry(2.1, 0.4, 2.8), bodyMat);
            top.position.set(0, 1.0, -0.4); top.castShadow = true; newCar.add(top);

            const windshield = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 1.1), glassMat);
            windshield.position.set(0, 1.1, 1.15); windshield.rotation.x = -Math.PI / 3.5; newCar.add(windshield);

            const rearWindow = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 1.0), glassMat);
            rearWindow.position.set(0, 1.1, -1.95); rearWindow.rotation.x = Math.PI / 3.5; rearWindow.rotation.y = Math.PI; newCar.add(rearWindow);

            const headLightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const hlL = new THREE.Mesh(headLightGeo, lightMat); hlL.position.set(-0.8, 0.6, 2.3); newCar.add(hlL);
            const hlR = new THREE.Mesh(headLightGeo, lightMat); hlR.position.set(0.8, 0.6, 2.3); newCar.add(hlR);

            const wheelGeo = new THREE.CylinderGeometry(0.42, 0.42, 0.45, 24);
            const wheelMat = new THREE.MeshStandardMaterial({color: 0x1a1a1a, roughness: 0.9});
            const addWheel = (wx, wz, front) => {
                const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI/2;
                const grp = new THREE.Group(); grp.add(w); grp.position.set(wx, 0.42, wz);
                newCar.add(grp); 
                if(isPlayer) wheels.push({mesh: grp, isFront: front});
            };
            addWheel(-1.1, 1.4, true); addWheel(1.1, 1.4, true);
            addWheel(-1.1, -1.4, false); addWheel(1.1, -1.4, false);

            newCar.position.set(x, 0, z);
            newCar.rotation.y = rot;
            scene.add(newCar);

            if(isPlayer) {
                car = newCar;
                carBody = base; 
            } else {
                obstacles.push(base); 
            }
        }

        function createParkingLines(x, z, rotY = 0) {
            parkingSpot = new THREE.Group();
            const lineMat = new THREE.MeshBasicMaterial({color: 0x00b894, side: THREE.DoubleSide}); 
            const lineWidth = 0.15; const spotWidth = 3.2; const spotLength = 5.5;
            
            const sideGeo = new THREE.PlaneGeometry(lineWidth, spotLength);
            const lineL = new THREE.Mesh(sideGeo, lineMat); lineL.rotation.x = -Math.PI/2; lineL.position.set(-spotWidth/2, 0, 0); parkingSpot.add(lineL);
            const lineR = new THREE.Mesh(sideGeo, lineMat); lineR.rotation.x = -Math.PI/2; lineR.position.set(spotWidth/2, 0, 0); parkingSpot.add(lineR);
            const backGeo = new THREE.PlaneGeometry(spotWidth + lineWidth, lineWidth);
            const lineB = new THREE.Mesh(backGeo, lineMat); lineB.rotation.x = -Math.PI/2; lineB.position.set(0, 0, -spotLength/2); parkingSpot.add(lineB);

            parkingSpot.position.set(x, 0.04, z);
            parkingSpot.rotation.y = rotY;
            environmentGroup.add(parkingSpot);
        }

        function createObstacleCar(d) {
            const colors = [0x74b9ff, 0xa29bfe, 0xfab1a0, 0x636e72, 0x55efc4];
            const color = colors[Math.floor(Math.random() * colors.length)];
            createCar(d.x, d.z, d.rot, color, false);
        }
        function createCone(d) {
            const c = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1, 16), new THREE.MeshStandardMaterial({color: 0xe67e22}));
            c.position.set(d.x, 0.5, d.z); c.castShadow = true; environmentGroup.add(c); obstacles.push(c);
        }
        function createCurbObstacle(d) {
             const curb = new THREE.Mesh(new THREE.BoxGeometry(d.w, 0.6, d.h), new THREE.MeshStandardMaterial({ color: 0xbdc3c7 }));
             curb.position.set(d.x, 0.3, d.z); curb.castShadow = true; environmentGroup.add(curb); obstacles.push(curb);
        }

        function updatePhysics() {
            if(!car || isGameOver) return;
            if(keys.w) speed += ACCEL; if(keys.s) speed -= ACCEL;
            speed *= FRICTION; if(Math.abs(speed) < 0.001) speed = 0;
            if(keys.a) steeringAngle += TURN_SPEED; if(keys.d) steeringAngle -= TURN_SPEED;
            if(!keys.a && !keys.d) steeringAngle *= 0.88; 
            if(steeringAngle > MAX_STEER) steeringAngle = MAX_STEER; if(steeringAngle < -MAX_STEER) steeringAngle = -MAX_STEER;
            if(Math.abs(speed) > 0.001) carRotation += steeringAngle * speed * 0.18;
            car.position.x += Math.sin(carRotation) * speed; car.position.z += Math.cos(carRotation) * speed;
            car.rotation.y = carRotation;
            wheels.forEach(w => { if(w.isFront) w.mesh.rotation.y = steeringAngle; });
            
            updateHUD();
            updateEngineSound();
            
            const offset = new THREE.Vector3(0, 25, -30); offset.applyAxisAngle(new THREE.Vector3(0,1,0), carRotation);
            const targetPos = new THREE.Vector3(car.position.x + offset.x, 25, car.position.z + offset.z);
            camera.position.lerp(targetPos, 0.1); camera.lookAt(car.position);
            
            checkCollisions(); checkWin();
        }

        function updateHUD() {
            document.getElementById('speed-display').innerText = Math.round(Math.abs(speed)*220);
            const dot = document.getElementById('steering-dot');
            const percent = 50 + (steeringAngle / MAX_STEER) * 50; dot.style.left = percent + "%";
            document.getElementById('gear-d').classList.toggle('active', speed > 0.01);
            document.getElementById('gear-n').classList.toggle('active', Math.abs(speed) <= 0.01);
            document.getElementById('gear-r').classList.toggle('active', speed < -0.01);
        }

        function checkCollisions() {
            // HATA ÇÖZÜMÜ: Eğer koruma süresi aktifse çarpışma kontrolü yapma
            if(!collisionEnabled || !carBody) return;

            // Kutu toleransını biraz artırdım (-0.3)
            const carBox = new THREE.Box3().setFromObject(carBody); carBox.expandByScalar(-0.3);
            for(let obs of obstacles) {
                const obsBox = new THREE.Box3().setFromObject(obs);
                if(carBox.intersectsBox(obsBox)) { speed = 0; playSFX('crash'); endGame(false); return; }
            }
        }
        function checkWin() {
            if(!parkingSpot) return;
            const dist = car.position.distanceTo(parkingSpot.position);
            const carDir = new THREE.Vector3(0,0,1).applyQuaternion(car.quaternion).normalize();
            const spotDir = new THREE.Vector3(0,0,1).applyQuaternion(parkingSpot.quaternion).normalize();
            const alignment = Math.abs(carDir.dot(spotDir));

            if(dist < 2.5 && Math.abs(speed) < 0.01 && alignment > 0.9) { playSFX('win'); endGame(true); }
        }
        function endGame(success) {
            isGameOver = true; const screen = document.getElementById('game-over-screen'); const title = document.getElementById('go-title'); const desc = document.getElementById('go-desc'); const btn = document.getElementById('go-btn');
            screen.style.display = 'flex';
            if(success) { title.innerText = "BAŞARILI"; title.style.color = "#00b894"; desc.innerText = "Mükemmel park ediş!"; btn.innerText = "SONRAKİ SEVİYE"; btn.onclick = nextLevel; } 
            else { title.innerText = "KAZA"; title.style.color = "#d63031"; desc.innerText = "Aracı çarptınız."; btn.innerText = "TEKRAR DENE"; btn.onclick = () => loadLevel(currentLevel); }
            stopEngine();
        }
        function handleKey(k, p) { k = k.toLowerCase(); if(k==='w'||k==='arrowup') keys.w=p; if(k==='s'||k==='arrowdown') keys.s=p; if(k==='a'||k==='arrowleft') keys.a=p; if(k==='d'||k==='arrowright') keys.d=p; }
        function setupTouch(id, k) { const b = document.getElementById(id); const s = (e)=>{e.preventDefault();keys[k]=true;b.classList.add('active');}; const e = (e)=>{e.preventDefault();keys[k]=false;b.classList.remove('active');}; b.addEventListener('touchstart', s); b.addEventListener('touchend', e); b.addEventListener('mousedown', s); b.addEventListener('mouseup', e); }
        function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
